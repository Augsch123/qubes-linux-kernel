From: Jeff Mahoney <jeffm@suse.com>
Subject: novfs: 2.6.37 api changes
Patch-mainline: If novfs gets merged

 2.6.37-rc1 removed the mutex interface to semaphores. This patch
 replaces uses of semaphores as mutex with the mutex interface.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/novfs/daemon.c  |   22 +++++++++++-----------
 fs/novfs/inode.c   |   33 +++++++++++++++++++--------------
 fs/novfs/profile.c |   10 +++++-----
 fs/novfs/scope.c   |    4 ++--
 4 files changed, 37 insertions(+), 32 deletions(-)

--- a/fs/novfs/daemon.c
+++ b/fs/novfs/daemon.c
@@ -109,7 +109,7 @@ static atomic_t Daemon_Open_Count = ATOM
 
 static unsigned long Daemon_Command_Timeout = TIMEOUT_VALUE;
 
-static DECLARE_MUTEX(DriveMapLock);
+static DEFINE_MUTEX(DriveMapLock);
 static LIST_HEAD(DriveMapList);
 
 int novfs_max_iosize = PAGE_SIZE;
@@ -118,7 +118,7 @@ void novfs_daemon_queue_init()
 {
 	INIT_LIST_HEAD(&Daemon_Queue.list);
 	spin_lock_init(&Daemon_Queue.lock);
-	init_MUTEX_LOCKED(&Daemon_Queue.semaphore);
+	sema_init(&Daemon_Queue.semaphore, 0);
 }
 
 void novfs_daemon_queue_exit(void)
@@ -159,7 +159,7 @@ int Queue_Daemon_Command(void *request,
 			que->status = QUEUE_SENDING;
 			que->flags = 0;
 
-			init_MUTEX_LOCKED(&que->semaphore);
+			sema_init(&que->semaphore, 0);
 
 			que->sequence = atomic_inc_return(&Sequence);
 
@@ -881,7 +881,7 @@ int novfs_daemon_destroy_sessionId(struc
 			 * When destroying the session check to see if there are any
 			 * mapped drives.  If there are then remove them.
 			 */
-			down(&DriveMapLock);
+			mutex_lock(&DriveMapLock);
 			list_for_each(list, &DriveMapList) {
 				dm = list_entry(list, struct drive_map, list);
 				if (SC_EQUAL(SessionId, dm->session)) {
@@ -892,7 +892,7 @@ int novfs_daemon_destroy_sessionId(struc
 				}
 
 			}
-			up(&DriveMapLock);
+			mutex_unlock(&DriveMapLock);
 
 		} else {
 			retCode = -EIO;
@@ -1740,7 +1740,7 @@ static int set_map_drive(struct novfs_xp
 
 	dm = (struct drive_map *)&DriveMapList.next;
 
-	down(&DriveMapLock);
+	mutex_lock(&DriveMapLock);
 
 	list_for_each(list, &DriveMapList) {
 		dm = list_entry(list, struct drive_map, list);
@@ -1766,7 +1766,7 @@ static int set_map_drive(struct novfs_xp
 		}
 	} else
 		kfree(drivemap);
-	up(&DriveMapLock);
+	mutex_unlock(&DriveMapLock);
 	return (retVal);
 }
 
@@ -1799,7 +1799,7 @@ static int unmap_drive(struct novfs_xpla
 
 	dm = NULL;
 
-	down(&DriveMapLock);
+	mutex_lock(&DriveMapLock);
 
 	list_for_each(list, &DriveMapList) {
 		dm = list_entry(list, struct drive_map, list);
@@ -1823,7 +1823,7 @@ static int unmap_drive(struct novfs_xpla
 		kfree(dm);
 	}
 
-	up(&DriveMapLock);
+	mutex_unlock(&DriveMapLock);
 	return (retVal);
 }
 
@@ -1832,7 +1832,7 @@ static void RemoveDriveMaps(void)
 	struct drive_map *dm;
 	struct list_head *list;
 
-	down(&DriveMapLock);
+	mutex_lock(&DriveMapLock);
 	list_for_each(list, &DriveMapList) {
 		dm = list_entry(list, struct drive_map, list);
 
@@ -1844,7 +1844,7 @@ static void RemoveDriveMaps(void)
 		list_del(&dm->list);
 		kfree(dm);
 	}
-	up(&DriveMapLock);
+	mutex_unlock(&DriveMapLock);
 }
 
 /* As picked from do_unlinkat() */
--- a/fs/novfs/inode.c
+++ b/fs/novfs/inode.c
@@ -43,7 +43,7 @@ struct inode_data {
 	struct inode *Inode;
 	unsigned long cntDC;
 	struct list_head DirCache;
-	struct semaphore DirCacheLock;
+	struct mutex DirCacheLock;
 	void *FileHandle;
 	int CacheFlag;
 	char Name[1];		/* Needs to be last entry */
@@ -268,11 +268,11 @@ static atomic_t novfs_Inode_Number = ATO
 struct dentry *novfs_root = NULL;
 char *novfs_current_mnt = NULL;
 
-DECLARE_MUTEX(InodeList_lock);
+DEFINE_MUTEX(InodeList_lock);
 
 LIST_HEAD(InodeList);
 
-DECLARE_MUTEX(TimeDir_Lock);
+DEFINE_MUTEX(TimeDir_Lock);
 uint64_t lastTime;
 char lastDir[PATH_MAX];
 
@@ -1050,7 +1050,7 @@ int novfs_dir_readdir(struct file *file,
 // Use this hack by default
 #ifndef SKIP_CROSSOVER_HACK
 	// Hack for crossover - begin
-	down(&TimeDir_Lock);
+	mutex_lock(&TimeDir_Lock);
 	if ((file->f_dentry->d_name.len == 7) &&
 	    ((0 == strncmp(file->f_dentry->d_name.name, " !xover", 7)) ||
 	     (0 == strncmp(file->f_dentry->d_name.name, "z!xover", 7)))) {
@@ -1076,7 +1076,7 @@ int novfs_dir_readdir(struct file *file,
 		}
 	}
 
-	up(&TimeDir_Lock);
+	mutex_unlock(&TimeDir_Lock);
 	// Hack for crossover - end
 #endif
 
@@ -3157,9 +3157,9 @@ void novfs_evict_inode(struct inode *ino
 
 		novfs_free_inode_cache(inode);
 
-		down(&InodeList_lock);
+		mutex_lock(&InodeList_lock);
 		list_del(&id->IList);
-		up(&InodeList_lock);
+		mutex_unlock(&InodeList_lock);
 
 		kfree(inode->i_private);
 		inode->i_private = NULL;
@@ -3292,15 +3292,15 @@ struct inode *novfs_get_inode(struct sup
 			id->cntDC = 1;
 
 			INIT_LIST_HEAD(&id->DirCache);
-			init_MUTEX(&id->DirCacheLock);
+			mutex_init(&id->DirCacheLock);
 
 			id->FileHandle = 0;
 			id->CacheFlag = 0;
 
-			down(&InodeList_lock);
+			mutex_lock(&InodeList_lock);
 
 			list_add_tail(&id->IList, &InodeList);
-			up(&InodeList_lock);
+			mutex_unlock(&InodeList_lock);
 
 			id->Name[0] = '\0';
 
@@ -3443,6 +3443,11 @@ static void novfs_kill_sb(struct super_b
 	kill_litter_super(super);
 }
 
+/* This should be removed */
+#ifndef kernel_locked
+#define kernel_locked() (current->lock_depth >= 0)
+#endif
+
 ssize_t novfs_Control_read(struct file *file, char *buf, size_t nbytes, loff_t * ppos)
 {
 	ssize_t retval = 0;
@@ -3532,7 +3537,7 @@ int novfs_lock_inode_cache(struct inode
 
 	DbgPrint("0x%p", i);
 	if (i && (id = i->i_private) && id->DirCache.next) {
-		down(&id->DirCacheLock);
+		mutex_lock(&id->DirCacheLock);
 		retVal = 1;
 	}
 	DbgPrint("return %d", retVal);
@@ -3544,7 +3549,7 @@ void novfs_unlock_inode_cache(struct ino
 	struct inode_data *id;
 
 	if (i && (id = i->i_private) && id->DirCache.next) {
-		up(&id->DirCacheLock);
+		mutex_unlock(&id->DirCacheLock);
 	}
 }
 
@@ -4042,7 +4047,7 @@ void novfs_dump_inode(void *pf)
 	char ctime_buf[32];
 	unsigned long icnt = 0, dccnt = 0;
 
-	down(&InodeList_lock);
+	mutex_lock(&InodeList_lock);
 	list_for_each(il, &InodeList) {
 		id = list_entry(il, struct inode_data, IList);
 		inode = id->Inode;
@@ -4087,7 +4092,7 @@ void novfs_dump_inode(void *pf)
 			}
 		}
 	}
-	up(&InodeList_lock);
+	mutex_unlock(&InodeList_lock);
 
 	pfunc("Inodes: %d(%d) DirCache: %d(%d)\n", InodeCount, icnt, DCCount, dccnt);
 
--- a/fs/novfs/profile.c
+++ b/fs/novfs/profile.c
@@ -60,7 +60,7 @@ static struct proc_dir_entry *dbg_file =
 static struct proc_dir_entry *dentry_file = NULL;
 static struct proc_dir_entry *inode_file = NULL;
 
-static DECLARE_MUTEX(LocalPrint_lock);
+static DEFINE_MUTEX(LocalPrint_lock);
 
 static ssize_t User_proc_write_DbgBuffer(struct file *file, const char __user * buf, size_t nbytes, loff_t * ppos)
 {
@@ -513,7 +513,7 @@ static ssize_t novfs_profile_read_inode(
 	static char save_DbgPrintOn;
 
 	if (offset == 0) {
-		down(&LocalPrint_lock);
+		mutex_lock(&LocalPrint_lock);
 		save_DbgPrintOn = DbgPrintOn;
 		DbgPrintOn = 0;
 
@@ -527,7 +527,7 @@ static ssize_t novfs_profile_read_inode(
 		DbgPrintOn = save_DbgPrintOn;
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
 
-		up(&LocalPrint_lock);
+		mutex_unlock(&LocalPrint_lock);
 	}
 
 	return retval;
@@ -541,7 +541,7 @@ static ssize_t novfs_profile_dentry_read
 	static char save_DbgPrintOn;
 
 	if (offset == 0) {
-		down(&LocalPrint_lock);
+		mutex_lock(&LocalPrint_lock);
 		save_DbgPrintOn = DbgPrintOn;
 		DbgPrintOn = 0;
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
@@ -554,7 +554,7 @@ static ssize_t novfs_profile_dentry_read
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
 		DbgPrintOn = save_DbgPrintOn;
 
-		up(&LocalPrint_lock);
+		mutex_unlock(&LocalPrint_lock);
 	}
 
 	return retval;
--- a/fs/novfs/scope.c
+++ b/fs/novfs/scope.c
@@ -601,8 +601,8 @@ char *novfs_scope_dget_path(struct dentr
 void novfs_scope_init(void)
 {
 	INIT_LIST_HEAD(&Scope_List);
-	init_MUTEX(&Scope_Lock);
-	init_MUTEX_LOCKED(&Scope_Thread_Delay);
+	sema_init(&Scope_Lock, 1);
+	sema_init(&Scope_Thread_Delay, 0);
 	kthread_run(Scope_Cleanup_Thread, NULL, "novfs_ST");
 }
 
